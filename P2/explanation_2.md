Again in this problem, I use concept of binary search. However instead of thinking the array as sorted, I think of position of 2 sequences i.e increasing sequence or decreasing sequence seperated by midpoint. First and second elements are checked to see if they sarisfy the condition second element > first element to be an increasing sequence. Once sequence type is determined, the number is checked to see if it is greater than the smallest element in the sequence or smaller than the last element. So if the number to be searched for lies in the increasing sequence, the search space is reduced by setting the first and the last to the sequence and the same process is repeated once again. This way, everytime we look for solution, we are reducing the search space to half or by some fraction times the original. Hence the overall complexity of the algorithm is O(nlog(n)).