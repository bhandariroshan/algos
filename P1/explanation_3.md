For this problem, I have created a priority queue using a linked list. There is also a pointer, that keeps track of last element. Everytime, I encounter a new element, I insert it at the last. So append has complexity of O(1). The pop function has O(1) complexity. The huffman_encoding takes constructs of list of dictionaries with alphabet as key and its frequency as value. This takes O(n) complexity. This list sorted based on the value so as to ensure we construct priority which has lowest frequency as highest priority and highest frequency as lowest priority. The complexity of sorting is O(nlog(n)). Then I construct priority queue which takes O(n) complexity as there are n elements in sorted array that needs to be appended. Finally once a tree is constructed, we then traverse the tree using recursion to find the huffman encoding for each unique alphabet.  The traverse_tree_get_encoding function used to find encoding for each alphabet, uses recursion. For each node in the tree it recursively finds the solution for left child and right child. This way, it has to travel all the nodes once. Hence the overall complexity of this function is, O(n). Finally using a dictinory of encoding for each alphabet, we then encode the string bit by bit and this operation has to make get query in the dictonary, which also takes O(n) for n alphabets. Hence the overall compelxity of this program is O(n) for all other oepration and O(nlog(n)) for sorting, making the overall worstcase complexity to be O(nlog(n)).